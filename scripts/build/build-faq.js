/* eslint-disable no-console */

const fs = require('fs');
const path = require('path');

const repoRoot = path.resolve(__dirname, '..', '..');

const FAQ_SOURCE_PATH = path.join(repoRoot, 'client', 'src', 'tuples', 'faq.js');
const INDEX_HTML_PATH = path.join(repoRoot, 'client', 'public', 'index.html');
const FAQ_MARKDOWN_PATH = path.join(repoRoot, 'docs', 'FAQ.md');

const START_MARKER =
  '<!-- FAQ_SCHEMA_JSONLD_START (auto-generated by scripts/build/build-faq.js) -->';
const END_MARKER = '<!-- FAQ_SCHEMA_JSONLD_END -->';

// Map topic names from tuples to markdown section names
const TOPIC_TO_SECTION = {
  'How It Works': 'General',
  'Celebrations': 'Celebrations',
  'Transparency': 'Transparency',
};

function assert(condition, message) {
  if (!condition) {
    throw new Error(message);
  }
}

function loadFaqTuples() {
  // Ensure we always read the latest file contents.
  // (Useful when running in watch/dev workflows.)
  delete require.cache[require.resolve(FAQ_SOURCE_PATH)];

  const faq = require(FAQ_SOURCE_PATH);
  assert(Array.isArray(faq), `Expected faq tuples to be an array at ${FAQ_SOURCE_PATH}`);

  return faq;
}

/**
 * Strip HTML tags from text, converting <a> tags to plain text with URL
 * This ensures JSON-LD schema has clean text without HTML markup
 */
function stripHtmlForSchema(text) {
  return String(text)
    // Convert <a href="url">text</a> to "text (url)"
    .replace(/<a\s+href=['"]([^'"]+)['"][^>]*>(.*?)<\/a>/gi, (match, url, linkText) => {
      return `${linkText.trim()} (${url})`;
    })
    // Strip any remaining HTML tags
    .replace(/<[^>]+>/g, '')
    // Decode HTML entities if any remain
    .replace(/&nbsp;/g, ' ')
    .replace(/&amp;/g, '&')
    .replace(/&lt;/g, '<')
    .replace(/&gt;/g, '>')
    .replace(/&quot;/g, '"')
    .trim();
}

function buildFaqSchema(faqTuples) {
  const questions = faqTuples.flatMap((section) => {
    const sectionQuestions = Array.isArray(section?.questions) ? section.questions : [];
    return sectionQuestions
      .filter((qa) => qa?.q && qa?.a)
      .map((qa) => ({
        '@type': 'Question',
        name: String(qa.q),
        acceptedAnswer: {
          '@type': 'Answer',
          text: stripHtmlForSchema(qa.a),
        },
      }));
  });

  return {
    '@context': 'https://schema.org',
    '@type': 'FAQPage',
    name: 'POWERBACK FAQ',
    mainEntity: questions,
  };
}

/**
 * Convert HTML to markdown format
 * Converts <a href="url">text</a> to [text](url)
 * Strips other HTML tags
 */
function htmlToMarkdown(text) {
  return String(text)
    // Convert <a href="url">text</a> to [text](url)
    .replace(/<a\s+href=['"]([^'"]+)['"][^>]*>(.*?)<\/a>/gi, (match, url, linkText) => {
      return `[${linkText.trim()}](${url})`;
    })
    // Strip any remaining HTML tags
    .replace(/<[^>]+>/g, '')
    // Decode HTML entities
    .replace(/&nbsp;/g, ' ')
    .replace(/&amp;/g, '&')
    .replace(/&lt;/g, '<')
    .replace(/&gt;/g, '>')
    .replace(/&quot;/g, '"')
    .trim();
}

function buildFaqMarkdown(faqTuples) {
  const sections = faqTuples
    .filter((section) => section?.topic && Array.isArray(section?.questions))
    .map((section) => {
      const sectionName = TOPIC_TO_SECTION[section.topic] || section.topic;
      const questions = section.questions
        .filter((qa) => qa?.q && qa?.a)
        .map((qa) => ({
          question: String(qa.q),
          answer: htmlToMarkdown(qa.a),
        }));

      return { sectionName, questions };
    });

  // Build markdown content
  const lines = ['# FAQ', ''];

  // Table of contents
  sections.forEach((section) => {
    const anchor = section.sectionName.toLowerCase().replace(/\s+/g, '-');
    lines.push(`- [${section.sectionName}](#${anchor})`);
  });
  lines.push('');

  // Sections
  sections.forEach((section) => {
    lines.push(`## ${section.sectionName}`);
    lines.push('');

    section.questions.forEach((qa) => {
      lines.push(`### ${qa.question}`);
      lines.push('');
      // Preserve answer formatting - split by newlines but keep meaningful structure
      const answerLines = qa.answer.split('\n').map((line) => line.trim());
      // If answer has multiple paragraphs (empty lines), preserve them
      if (answerLines.some((line) => line === '')) {
        answerLines.forEach((line) => {
          if (line === '') {
            lines.push('');
          } else {
            lines.push(line);
          }
        });
      } else {
        // Single paragraph - join with spaces
        lines.push(answerLines.filter((line) => line.length > 0).join(' '));
      }
      lines.push('');
    });
  });

  return lines.join('\n');
}

function indentLines(text, indent) {
  const prefix = ' '.repeat(indent);
  return text
    .split('\n')
    .map((line) => `${prefix}${line}`)
    .join('\n');
}

function injectIntoIndexHtml(indexHtml, jsonLdObject) {
  const json = JSON.stringify(jsonLdObject, null, 2);

  const startIndex = indexHtml.indexOf(START_MARKER);
  const endIndex = indexHtml.indexOf(END_MARKER);

  assert(
    (startIndex === -1 && endIndex === -1) || (startIndex !== -1 && endIndex !== -1),
    'FAQ schema markers are mismatched in client/public/index.html'
  );

  // Replace existing marked block.
  if (startIndex !== -1 && endIndex !== -1) {
    const baseIndent = '  ';
    const replacementBlock = [
      `${baseIndent}${START_MARKER}`,
      `${baseIndent}<script type="application/ld+json">`,
      indentLines(json, baseIndent.length + 2),
      `${baseIndent}</script>`,
      `${baseIndent}${END_MARKER}`,
    ].join('\n');

    const replaceStart = indexHtml.lastIndexOf('\n', startIndex - 1) + 1;
    const afterEnd = endIndex + END_MARKER.length;
    const endOfEndLine = indexHtml.indexOf('\n', afterEnd);
    const replaceEnd = endOfEndLine === -1 ? indexHtml.length : endOfEndLine + 1;

    return `${indexHtml.slice(0, replaceStart)}${replacementBlock}\n${indexHtml.slice(replaceEnd)}`;
  }

  // If markers are missing, insert after the twitter image meta.
  const anchor = '<meta name="twitter:image" content="%PUBLIC_URL%/banner.webp" />';
  const anchorIndex = indexHtml.indexOf(anchor);

  assert(anchorIndex !== -1, 'Could not find insertion point meta tag in index.html');

  const insertAt = anchorIndex + anchor.length;
  const baseIndent = '  ';

  const replacementBlock = [
    `${baseIndent}${START_MARKER}`,
    `${baseIndent}<script type="application/ld+json">`,
    indentLines(json, baseIndent.length + 2),
    `${baseIndent}</script>`,
    `${baseIndent}${END_MARKER}`,
  ].join('\n');

  return `${indexHtml.slice(0, insertAt)}\n${replacementBlock}${indexHtml.slice(insertAt)}`;
}

function updateMarkdownFile(markdownContent) {
  const existingContent = fs.existsSync(FAQ_MARKDOWN_PATH)
    ? fs.readFileSync(FAQ_MARKDOWN_PATH, 'utf8')
    : '';

  if (existingContent !== markdownContent) {
    fs.writeFileSync(FAQ_MARKDOWN_PATH, markdownContent, 'utf8');
    return true;
  }
  return false;
}

function main() {
  const faqTuples = loadFaqTuples();
  const schema = buildFaqSchema(faqTuples);
  const markdown = buildFaqMarkdown(faqTuples);

  // Update JSON-LD schema in index.html
  const indexHtml = fs.readFileSync(INDEX_HTML_PATH, 'utf8');
  const updatedHtml = injectIntoIndexHtml(indexHtml, schema);

  let htmlUpdated = false;
  if (updatedHtml !== indexHtml) {
    fs.writeFileSync(INDEX_HTML_PATH, updatedHtml, 'utf8');
    console.log('✓ Updated FAQ JSON-LD in client/public/index.html');
    htmlUpdated = true;
  }

  // Update markdown documentation
  const markdownUpdated = updateMarkdownFile(markdown);

  if (markdownUpdated) {
    console.log('✓ Updated FAQ markdown in docs/FAQ.md');
  }

  if (!htmlUpdated && !markdownUpdated) {
    console.log('✓ FAQ outputs already up to date');
  }
}

main();

